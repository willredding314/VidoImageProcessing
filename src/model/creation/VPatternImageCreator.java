package model.creation;

import java.awt.Color;
import model.image.VMutableImage;
import model.image.VMutableImageImpl;
import model.image.pixel.VPixelCoordinate;
import model.image.pixel.VRGBPixel;
import model.misc.ObjectsExtension;

/**
 * A factory class which produces programmatically generated image providers.
 *
 * <p>The {@link VPatternImageCreator} is a factory for producing
 * image generators. For example, you can produce image generators which themselves produce
 * checkerboard images of a certain width and height, certain colors, and certain square size. The
 * factory is useful for reusing pre-defined patterns. For greater flexibility, clients should
 * implement the {@link VImageProvider} interface to their particular situation.</p>
 */
public final class VPatternImageCreator {
  private VPatternImageCreator() {
    // Prevent construction
  }

  /**
   * Creates an image provider instance which creates checkerboard images
   * with the given specifications.
   *
   * <p>Use this method to produce an image generator for a particular checkerboard
   * pattern procedurally generated according to the parameters passed in.
   *
   * <p>Screens only have an integer number of pixels available to them at any
   * time; fractional pixels must be defined by any implementation. The size of the
   * image takes priority over the size of the checkerboard squares in generating
   * images. Thus, the patterns produced may not have precisely square checkerboard
   * squares should it not be possible to evenly divide the screen into squares.
   *
   * <p>In the event the width or height cannot be broken evenly amongst
   * the squares to be created by the image provider, the pattern will continue
   * to alternate as expected, with the <em>last</em> checkerboard square in the
   * image having a smaller width or height than the previous squares.</p>
   *
   * @param imgWidth the height of the images produced by the new provider
   * @param imgHeight the width of the images produced by the new provider
   * @param cWidth the width of the individual checkerboard squares within the
   *               images generated by the image provider produced
   * @param cHeight the height of the individual checkerboard squares within the
   *                images generated by the image provider produced
   * @param darkColor the color of the squares considered "dark". This is
   *                  {@link Color#black} in a classic checkerboard pattern.
   * @param lightColor the color of the squares considered "light". This is
   *                   {@link Color#white} in a classic checkerboard pattern.
   * @return a new object which produces checkerboard images formatted
   *         according to the parameters of the method
   * @throws IllegalArgumentException if the image width, image height,
   *                                  checkerboard square width, or
   *                                  checkerboard square height are negative or 0;
   *                                  or if the width or height of the checkerboard square
   *                                  exceeds that of the actual image;
   *                                  or if {@code darkColor} or {@code lightColor}
   *                                  are null
   */
  public static VImageProvider checkerboardImageProvider(int imgWidth, int imgHeight, int cWidth,
      int cHeight, Color darkColor, Color lightColor) throws IllegalArgumentException {
    ObjectsExtension.requireNonnull(darkColor, lightColor);

    if (imgHeight <= 0 || imgWidth <= 0 || cHeight <= 0 || cWidth <= 0) {
      throw new IllegalArgumentException("All sizes must be positive");
    }

    if (imgHeight < cHeight || imgWidth < cWidth) {
      throw new IllegalArgumentException("The squares in the checkerboard "
          + "cannot be larger than the image itself");
    }

    return () -> {
      VMutableImage image = new VMutableImageImpl(imgWidth, imgHeight);

      for (int i = 0; i < imgHeight; i += 1) {
        for (int j = 0; j < imgWidth; j += 1) {

          boolean evenRow = i / cHeight % 2 == 0;
          boolean evenColumn = j / cWidth % 2 == 0;

          boolean useDarkColor = evenRow == evenColumn;
          Color fillColor = useDarkColor ? darkColor : lightColor;

          image.setPixel(new VRGBPixel(fillColor), new VPixelCoordinate(i, j));
        }
      }

      return image;
    };
  }
}
